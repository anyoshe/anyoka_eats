                           +----------------+
                           |  User Interface |
                           +--------+-------+
                                    |
                                    |
                                    v
                           +----------------+
                           |   React Frontend |
                           +--------+-------+
                                    |
                                    |
           +------------------------+-----------------------+
           |                        |                       |
           v                        v                       v
+-----------------+      +-------------------+      +---------------------+
| User Management |      |   Job Matching    |      | Career Counseling    |
|   (Authentication) |      |   (Taxonomy +    |      |    (Classifier)     |
|   (Register/Login)  |      |    Compass)      |      |   (Recommendations)  |
+--------+--------+      +---------+---------+      +----------+----------+
         |                           |                            |
         |                           |                            |
         v                           |                            v
+-----------------+                  v                   +---------------------+
|  MongoDB        |        +-------------------+       |    Educational Tool   |
|  Database       |        |    Job Listings    |       | (Compass for Skill  |
| (Users & Taxonomy) |    +-------------------+       |   Development)      |
+-----------------+        |  Skill Mapping     |       +---------------------+
                           +-------------------+



import React, { useState, useEffect } from 'react';
import './DriverDashboard.css';
import '@fortawesome/fontawesome-free/css/all.min.css';
import config from '../../config';
import { useNavigate } from 'react-router-dom';


const Dashboard = () => {
    const [isOnline, setIsOnline] = useState(false);
    const [showProfileCard, setShowProfileCard] = useState(false);
    const [selectedOrder, setSelectedOrder] = useState(null);
    const [orders, setOrders] = useState([]);
    const [driverDetails, setDriverDetails] = useState({});
    const [location, setLocation] = useState('');
    const [contactNumber, setContactNumber] = useState('');
    const [vehicleType, setVehicleType] = useState('');
    const [driverImage, setDriverImage] = useState(null); // New state for driver image
    const [editing, setEditing] = useState(false); // State to toggle editing mode
    const [timer, setTimer] = useState(0); // Timer state for the countdown
    const [orderTimerId, setOrderTimerId] = useState(null); // Timer ID for clearing later
    const [driverId, setDriverId] = useState(null); // Initialize state for driverId
    // const [dispatchedOrders, setDispatchedOrders] = useState([]);
    const [orderId, setOrderId] = useState(null); // State to hold orderId
    const [orderStatus, setOrderStatus] = useState('');
    const [normalOrders, setNormalOrders] = useState([]);
    const [foodOrders, setFoodOrders] = useState([]);




    const navigate = useNavigate();

    useEffect(() => {
        const storedDriverId = localStorage.getItem('driverId'); // Retrieve the driver ID from local storage
        if (storedDriverId) {
            console.log('Driver ID set in local storage:', storedDriverId); // Log the driverId instead
            setDriverId(storedDriverId); // Set driverId state
        } else {
            console.error('Driver ID not found in local storage');
        }
    }, []); // This runs once on mount to get the driverId

    useEffect(() => {
        if (driverId) {
            fetchDriverDetails(driverId); // Fetch driver details using the stored driver ID
            // fetchDispatchedOrders(driverId); // Fetch dispatched orders using the stored driver ID
            fetchOrders(); // Call fetchOrders if necessary
            // restoreTimerState();
            fetchOrderByStatus();
        }
    }, [driverId]); // This runs whenever driverId changes


    const fetchDriverDetails = async (driverId) => {
        console.log('Fetching details for Driver ID:', driverId); // Log the driverId
        try {
            const response = await fetch(`${config.backendUrl}/api/driverDetails/${driverId}`);
            console.log('Response status:', response.status);

            const text = await response.text();
            console.log('Response text:', text);

            if (!response.ok) {
                throw new Error('Failed to fetch driver details');
            }

            const data = JSON.parse(text);
            console.log('Fetched Driver Details:', data);

            // Check for driver ID in the response
            if (!data._id) {
                console.error('Driver ID is missing in the fetched data');
                return;
            }
            // Construct the full driver image URL
            const driverImage = `${config.backendUrl}${data.driverImage}`;

            // Update state with fetched data
            setDriverDetails(data);
            console.log('Driver Details set:', data);
            setLocation(data.location || '');
            setContactNumber(data.contactNumber || '');
            setVehicleType(data.vehicleType || '');
            setDriverImage(driverImage || null);
        } catch (error) {
            console.error('Failed to fetch driver details:', error);
        }
    };

    const toggleOnlineStatus = () => {
        setIsOnline(prev => !prev);
    };

    const handleProfileClick = () => {
        setShowProfileCard(prev => !prev);
    };


    window.onload = () => {
        checkForOngoingOrder(); // First check if the driver has an ongoing order
        monitorOrderStatus(); // Monitor the order status to remove it upon delivery or driver decline
    };

    // Function to check for ongoing order and restore state
    // const checkForOngoingOrder = () => {
    //     const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
    //     const savedTime = localStorage.getItem(`driver_${driverId}_timerStartTime`);

    //     if (savedOrder && savedTime) {
    //         const elapsedTime = Math.floor((Date.now() - parseInt(savedTime)) / 1000);
    //         const remainingTime = 300 - elapsedTime; // 5 minutes (300 seconds) - elapsed time

    //         if (remainingTime > 0) {
    //             setSelectedOrder(JSON.parse(savedOrder)); // Restore the saved order for the specific driver
    //             startTimer(JSON.parse(savedOrder).orderId, driverId); // Resume the timer for this driver
    //             setTimer(remainingTime); // Restore the remaining time
    //         } else {
    //             // Timer has already expired, revert order status for this driver
    //             revertOrderStatus(JSON.parse(savedOrder).orderId, driverId);

    //             // Clear localStorage as the timer expired
    //             localStorage.removeItem(`driver_${driverId}_currentOrder`);
    //             localStorage.removeItem(`driver_${driverId}_timerStartTime`);
    //             localStorage.removeItem(`driver_${driverId}_remainingTime`);

    //             // No ongoing order, so fetch new orders
    //             fetchOrders();
    //         }
    //     } else {
    //         console.log("No ongoing order found for driver, fetching new orders");
    //         // No ongoing order, so fetch new orders
    //         fetchOrders();
    //     }
    // };
    const checkForOngoingOrder = async () => {
        const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
        const savedTime = localStorage.getItem(`driver_${driverId}_timerStartTime`);

        if (savedOrder && savedTime) {
            const elapsedTime = Math.floor((Date.now() - parseInt(savedTime)) / 1000);
            const remainingTime = 300 - elapsedTime; // 5 minutes (300 seconds) - elapsed time

            if (remainingTime > 0) {
                setSelectedOrder(JSON.parse(savedOrder)); // Restore the saved order for the specific driver
                startTimer(JSON.parse(savedOrder).orderId, driverId); // Resume the timer for this driver
                setTimer(remainingTime); // Restore the remaining time
            } else {
                // Timer has already expired, revert order status for this driver
                revertOrderStatus(JSON.parse(savedOrder).orderId, driverId);

                // Clear localStorage as the timer expired
                localStorage.removeItem(`driver_${driverId}_currentOrder`);
                localStorage.removeItem(`driver_${driverId}_timerStartTime`);
                localStorage.removeItem(`driver_${driverId}_remainingTime`);

                // No ongoing order, so fetch new orders
                fetchOrders();
            }
        } else {
            console.log("No ongoing order found for driver, checking for dispatched food orders");

            // Check for dispatched food orders first
            const dispatchedFoodOrders = await fetchDispatchedFoodOrders(driverId);
            if (dispatchedFoodOrders.length === 0) {
                console.log("No dispatched food orders found, fetching new orders");
                // No dispatched food orders, so fetch new orders
                fetchOrders();
            }
        }
    };



    const fetchOrders = async () => {
        try {
            // Fetch all orders
            const allOrdersResponse = await fetch(`${config.backendUrl}/api/orders`);
            const allOrdersData = await allOrdersResponse.json();
            console.log('Normal dish orders:', allOrdersData);

            // Initialize readyForPickupData
            let readyForPickupData = [];

            // Fetch orders that are ready for pickup
            try {
                const readyForPickupResponse = await fetch(`${config.backendUrl}/api/driverDashboard/orders/readyForPickup`);
                if (!readyForPickupResponse.ok) {
                    throw new Error(`HTTP error! status: ${readyForPickupResponse.status}`);
                }

                readyForPickupData = await readyForPickupResponse.json();
                console.log('Ready for pickup orders:', readyForPickupData);
            } catch (error) {
                console.warn('Could not fetch ready for pickup orders:', error);
            }

            // Check if the responses are arrays
            if (!Array.isArray(allOrdersData)) {
                console.error('Unexpected response format for all orders:', allOrdersData);
                return;
            }

            // Filter and format the processed normal dish orders
            const processedOrders = allOrdersData.filter(order => order.status === 'Processed and packed');
            const formattedProcessedOrders = processedOrders.map(order => ({
                id: order._id,
                name: order.selectedRestaurant,
                pickup: order.selectedRestaurantLocation || order.selectedRestaurant,
                order: order.orderId,
                dropoff: order.customerLocation,
                deliveryCharges: `Ksh ${order.deliveryCharges}`,
                commission: `Ksh ${order.deliveryCharges * 0.2}`,
                netPay: `Ksh ${order.deliveryCharges - (order.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(order.expectedDeliveryTime).toLocaleString(),
                phoneNumber: order.phoneNumber,
                status: order.status,
                dishes: order.dishes,
            }));
            console.log('Processed normal dish orders:', formattedProcessedOrders);

            // Fetch all food orders (new step)
            const allFoodOrdersResponse = await fetch(`${config.backendUrl}/api/foodOrders`);
            const allFoodOrdersData = await allFoodOrdersResponse.json();
            console.log('All food orders:', allFoodOrdersData);

            // Filter and format the processed food orders
            const processedFoodOrders = allFoodOrdersData.filter(foodOrder => foodOrder.status === 'Processed and packed');
            const formattedProcessedFoodOrders = processedFoodOrders.map(foodOrder => ({
                id: foodOrder._id,
                name: foodOrder.selectedRestaurant,
                pickup: foodOrder.selectedRestaurantLocation || foodOrder.selectedRestaurant,
                order: foodOrder.orderId,
                dropoff: foodOrder.customerLocation,
                deliveryCharges: `Ksh ${foodOrder.deliveryCharges}`,
                commission: `Ksh ${foodOrder.deliveryCharges * 0.2}`,
                netPay: `Ksh ${foodOrder.deliveryCharges - (foodOrder.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(foodOrder.expectedDeliveryTime).toLocaleString(),
                phoneNumber: foodOrder.phoneNumber,
                status: foodOrder.status,
                dishes: foodOrder.dishes,
            }));
            console.log('Processed food orders:', formattedProcessedFoodOrders);

            // Format the ready for pickup orders only if readyForPickupData is an array
            const formattedReadyForPickupOrders = Array.isArray(readyForPickupData) ? readyForPickupData.map(order => ({
                id: order._id,
                name: order.selectedRestaurant,
                pickup: order.selectedRestaurantLocation || order.selectedRestaurant,
                order: order.orderId,
                dropoff: order.customerLocation,
                deliveryCharges: `Ksh ${order.deliveryCharges}`,
                commission: `Ksh ${order.deliveryCharges * 0.2}`,
                netPay: `Ksh ${order.deliveryCharges - (order.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(order.expectedDeliveryTime).toLocaleString(),
                phoneNumber: order.phoneNumber,
                status: order.overallStatus,
                vendorOrders: order.vendorOrders.map(vendorOrder => ({
                    vendor: vendorOrder.vendor,
                    totalPrice: vendorOrder.totalPrice,
                    foods: vendorOrder.foods.map(food => ({
                        foodName: food.foodName,
                        quantity: food.quantity,
                        price: `Ksh ${food.price}`,
                    })),
                })),
            })) : [];

            // Combine both formatted orders
            const combinedOrders = [...formattedProcessedOrders, ...formattedProcessedFoodOrders, ...formattedReadyForPickupOrders];

            // Update the state with the combined orders
            setOrders(combinedOrders);
        } catch (error) {
            console.error('Failed to fetch orders:', error);
        }
    };

    // Function to monitor order status changes (e.g., after delivery or driver decline)
    const monitorOrderStatus = async () => {
        const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
        if (savedOrder) {
            const { orderId } = JSON.parse(savedOrder);

            try {
                // Fetch the current order status from the backend
                const response = await fetch(`${config.backendUrl}/api/getOrderStatus/${orderId}`);
                const orderData = await response.json();

                if (orderData.status === 'Delivered' || orderData.status === 'Declined') {
                    // Remove order from view and clear localStorage
                    setSelectedOrder(null);
                    localStorage.removeItem(`driver_${driverId}_currentOrder`);
                    localStorage.removeItem(`driver_${driverId}_timerStartTime`);
                    localStorage.removeItem(`driver_${driverId}_remainingTime`);
                }
            } catch (error) {
                console.error('Error fetching order status:', error);
            }
        }
    };


    // const handleAcceptOrder = async (order) => {
    //     const orderId = order?.order;
    //     console.log("Order being accepted:", orderId);
    //     console.log("Driver ID:", driverId); // Log the driverId to verify it's being passed correctly


    //     if (!orderId) {
    //         console.error("Order ID is undefined!");
    //         return; 
    //     }

    //     try {
    //         if (!driverId) {
    //             throw new Error('Driver ID is not set');
    //         }

    //         let response;
    //         let isFoodOrder = false;

    //         // Check if it's a food (vendor) order or a regular restaurant order
    //         if (order.vendorOrders && order.vendorOrders.length > 0) {
    //             isFoodOrder = true; // Flag for fresh food order

    //             // Update parent food order status to 'Dispatched'
    //             response = await fetch(`${config.backendUrl}/api/driverUpdateFoodOrderStatus/${orderId}`, {
    //                 method: 'PATCH',
    //                 headers: {
    //                     'Content-Type': 'application/json',
    //                 },

    //                 body: JSON.stringify({
    //                     status: 'Dispatched', 
    //                     driverId
    //                 })
    //             });
    //             console.log("Driver ID being sent:", driverId);  // Ensure driverId is set and being sent


    //             if (!response.ok) {
    //                 throw new Error('Failed to update parent food order status');
    //             }

    //             // Update each vendor order's status to 'Dispatched'
    //             for (let vendorOrder of order.vendorOrders) {
    //                 const vendorId = vendorOrder?._id;  // Safely retrieve the vendor ID

    //                 if (!vendorId) {
    //                     console.warn("Vendor order without ID detected. Full details:", vendorOrder);
    //                     console.warn("Vendor ID is undefined! Skipping this vendor order.");
    //                     continue; // Skip this iteration if vendorId is not found
    //                 } else {
    //                     console.log("Processing vendor with ID:", vendorId, "Vendor details:", vendorOrder);
    //                 }

    //                 try {
    //                     const vendorResponse = await fetch(`${config.backendUrl}/api/updateVendorOrderStatus/${vendorId}`, {
    //                         method: 'PATCH',
    //                         headers: {
    //                             'Content-Type': 'application/json',
    //                         },
    //                         body: JSON.stringify({
    //                             status: 'Dispatched'
    //                         })
    //                     });

    //                     if (!vendorResponse.ok) {
    //                         throw new Error(`Failed to update vendor order status for vendor: ${vendorOrder.vendor}`);
    //                     }

    //                     const updatedVendorOrder = await vendorResponse.json();
    //                     console.log(`Vendor order updated to 'Dispatched':`, updatedVendorOrder);

    //                 } catch (error) {
    //                     console.error(`Error updating vendor order with ID ${vendorId}:`, error);
    //                 }
    //             }


    //         } else {
    //             // Update restaurant order status
    //             response = await fetch(`${config.backendUrl}/api/driverUpdateOrderStatus/${orderId}`, {
    //                 method: 'PATCH',
    //                 headers: {
    //                     'Content-Type': 'application/json',
    //                 },
    //                 body: JSON.stringify({
    //                     status: 'Dispatched', 
    //                     driverId
    //                 })
    //             });

    //             if (!response.ok) {
    //                 throw new Error('Failed to accept the order');
    //             }
    //         }

    //         const updatedOrder = await response.json();
    //         console.log('Order accepted and dispatched:', updatedOrder);

    //         // Start the timer
    //         setTimer(7 * 60); // 7 minutes
    //         startTimer(updatedOrder.orderId, driverId);
    const handleAcceptOrder = async (order) => {
        const orderId = order?.order;
        console.log("Order being accepted:", orderId);
        console.log("Driver ID:", driverId);

        if (!orderId) {
            console.error("Order ID is undefined!");
            return;
        }

        try {
            if (!driverId) {
                throw new Error('Driver ID is not set');
            }

            let response;
            let isFoodOrder = false;

            // Check if it's a food (vendor) order or a regular restaurant order
            if (order.vendorOrders && order.vendorOrders.length > 0) {
                isFoodOrder = true; // Flag for fresh food order

                // Update parent food order status to 'Dispatched'
                response = await fetch(`${config.backendUrl}/api/driverUpdateFoodOrderStatus/${orderId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        status: 'Dispatched',
                        driverId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to update parent food order status');
                }

                // Update each vendor order's status to 'Dispatched'
                for (let vendorOrder of order.vendorOrders) {
                    const vendorId = vendorOrder?._id;

                    if (!vendorId) {
                        console.warn("Vendor order without ID detected. Full details:", vendorOrder);
                        continue;
                    }

                    try {
                        const vendorResponse = await fetch(`${config.backendUrl}/api/updateVendorOrderStatus/${vendorId}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                status: 'Dispatched'
                            })
                        });

                        if (!vendorResponse.ok) {
                            throw new Error(`Failed to update vendor order status for vendor: ${vendorOrder.vendor}`);
                        }

                        const updatedVendorOrder = await vendorResponse.json();
                        console.log(`Vendor order updated to 'Dispatched':`, updatedVendorOrder);

                    } catch (error) {
                        console.error(`Error updating vendor order with ID ${vendorId}:`, error);
                    }
                }

                // After updating all vendor orders, fetch and update the food order state
                const fetchedFoodOrder = await fetchOrderByStatus(orderId, driverId, isFoodOrder);
                setFoodOrders(prev => [...prev, fetchedFoodOrder]); // Add the fetched food order to state

            } else {
                // Update restaurant order status
                response = await fetch(`${config.backendUrl}/api/driverUpdateOrderStatus/${orderId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        status: 'Dispatched',
                        driverId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to accept the order');
                }
            }

            const updatedOrder = await response.json();
            console.log('Order accepted and dispatched:', updatedOrder);

            // Start the timer
            setTimer(7 * 60); // 7 minutes
            startTimer(updatedOrder.orderId, driverId);

            // Clear other orders from the view
            setOrders([]);

            // Store the driver-specific order in localStorage
            localStorage.setItem(`driver_${driverId}_order`, JSON.stringify({ orderId: updatedOrder.order, driverId }));

            // Start checking the order status every 90 seconds
            await fetchOrderByStatus(updatedOrder.orderId, driverId, isFoodOrder);
            startOrderStatusCheck(updatedOrder.orderId, driverId);

        } catch (error) {
            console.error('Error accepting order:', error);
        }
    };

    const fetchOrderByStatus = async (orderId, driverId) => {
        try {
            console.log("Fetching order by status for Order ID:", orderId, "and Driver ID:", driverId);

            // Attempt to fetch the normal order first
            const normalOrderEndpoint = `${config.backendUrl}/api/fetchOrderByStatus/${orderId}/${driverId}`;
            console.log("Using normal order endpoint:", normalOrderEndpoint); // Debug log for the selected endpoint

            let response = await fetch(normalOrderEndpoint);
            console.log("Normal Order Response status:", response.status); // Log the response status

            if (!response.ok) {
                console.error('Normal order fetch failed, trying food order...');
                // Attempt to fetch the food order if normal order fails
                const foodOrderEndpoint = `${config.backendUrl}/api/fetchFoodOrderByStatus/${orderId}/${driverId}`;
                console.log("Using food order endpoint:", foodOrderEndpoint); // Debug log for the food order endpoint

                response = await fetch(foodOrderEndpoint);
                console.log("Food Order Response status:", response.status); // Log the response status

                if (!response.ok) {
                    throw new Error(`Failed to fetch the food order by status. Status: ${response.status}`);
                }
            }

            // If we have a successful response, parse the order
            const fetchedOrder = await response.json();
            console.log("Fetched order:", fetchedOrder);

            if (!fetchedOrder) {
                throw new Error("No order data found");
            }

            return fetchedOrder; // Return the fetched order data
        } catch (error) {
            console.error('Error fetching order by status:', error);
            return null; // Return null if there's an error
        }
    };



    const startTimer = (orderId, driverId) => {
        if (orderTimerId) clearInterval(orderTimerId); // Clear previous timer if exists

        console.log(`Starting timer for Order ID: ${orderId}, Driver ID: ${driverId}`);

        const id = setInterval(async () => {
            console.log('Checking order status and updating timer...');

            // First, try to fetch the normal order status
            let fetchedOrder = await fetchOrderByStatus(orderId, driverId);

            // If the normal order is not found, attempt to fetch the food order
            if (!fetchedOrder) {
                console.log('Normal order not found, trying to fetch food order...');
                fetchedOrder = await fetchOrderByStatus(orderId, driverId, true); // Fetch food order
            }

            // Handle undefined or null fetchedOrder
            if (!fetchedOrder) {
                console.log('No order data found, stopping timer.');
                clearInterval(id);
                return;
            }

            console.log('Fetched order status:', fetchedOrder.status || fetchedOrder.overallStatus); // Log status

            // Determine which status to use
            const orderStatus = fetchedOrder.status || fetchedOrder.overallStatus;

            // Only continue counting down if the status is 'Dispatched'
            if (orderStatus === 'Dispatched') {
                setTimer(prev => {
                    console.log("Timer countdown:", prev);
                    if (prev <= 0) {
                        clearInterval(id);
                        console.log("Timer ended, calling revertOrderStatus");
                        revertOrderStatus(orderId, driverId);
                        clearDriverStorage(driverId); // Clear localStorage once timer ends
                        return 0;
                    }
                    return prev - 1; // Decrease the timer
                });
            } else {
                console.log(`Order status is ${orderStatus}, stopping timer.`);
                clearInterval(id);
            }
        }, 1000); // Check every second

        setOrderTimerId(id); // Save the timer ID
    };

    // const startTimer = (orderId, driverId) => {
    //     if (orderTimerId) clearInterval(orderTimerId); // Clear previous timer if exists

    //     console.log(`Starting timer for Order ID: ${orderId}, Driver ID: ${driverId}`);

    //     const id = setInterval(async () => {
    //         console.log('Checking order status and updating timer...');

    //         // Try to fetch the order status
    //         let fetchedOrder = await fetchOrderByStatus(orderId, driverId);

    //         // If the normal order is not found, attempt to fetch the food order
    //         if (!fetchedOrder) {
    //             console.log('Normal order not found, trying to fetch food order...');
    //             fetchedOrder = await fetchOrderByStatus(orderId, driverId, true); // Fetch food order
    //         }

    //         if (!fetchedOrder) {
    //             console.log('No order data found, stopping timer.');
    //             clearInterval(id);
    //             return;
    //         }

    //         const orderStatus = fetchedOrder.status || fetchedOrder.overallStatus;
    //         console.log('Fetched order status:', orderStatus);

    //         // Only continue counting down if the status is 'Dispatched'
    //         if (orderStatus === 'Dispatched') {
    //             setTimer(prev => {
    //                 console.log("Timer countdown:", prev);
    //                 if (prev <= 0) {
    //                     clearInterval(id);
    //                     console.log("Timer ended, calling revertOrderStatus");
    //                     revertOrderStatus(orderId, driverId);
    //                     clearDriverStorage(driverId); // Clear localStorage once timer ends
    //                     return 0;
    //                 }
    //                 return prev - 1; // Decrease the timer
    //             });
    //         } else {
    //             console.log(`Order status is ${orderStatus}, stopping timer.`);
    //             clearInterval(id);
    //         }
    //     }, 1000); // Check every second

    //     setOrderTimerId(id); // Save the timer ID
    // };


    const clearDriverStorage = (driverId) => {
        localStorage.removeItem(`driver_${driverId}_currentOrder`);
        localStorage.removeItem(`driver_${driverId}_timerStartTime`);
        localStorage.removeItem(`driver_${driverId}_remainingTime`);
    };

    const startOrderStatusCheck = (orderId, driverId) => {
        console.log(`Starting status check for Order ID: ${orderId}, Driver ID: ${driverId}`);
        const intervalId = setInterval(async () => {
            try {
                const response = await fetch(`${config.backendUrl}/api/fetchOrderByStatus/${orderId}/${driverId}`);
                if (!response.ok) {
                    console.error('Failed to fetch the order status, trying food orders...');
                    // If the normal order fetch fails, try fetching the food order
                    const foodResponse = await fetch(`${config.backendUrl}/api/fetchFoodOrderByStatus/${orderId}/${driverId}`);
                    if (!foodResponse.ok) {
                        throw new Error('Failed to fetch the food order status');
                    }

                    const fetchedFoodOrder = await foodResponse.json();
                    console.log("Fetched food order status during 90s check:", fetchedFoodOrder.overallStatus);

                    // Process food order status
                    if (fetchedFoodOrder.overallStatus === 'On Transit') {
                        console.log("Food order is now on transit. Stopping checks and timer.");
                        clearInterval(intervalId); // Stop the status check
                        clearInterval(orderTimerId); // Stop the timer
                        // Call a function to update the UI to mark as delivered
                        markOrderAsDelivered(fetchedFoodOrder);
                        return;
                    }
                } else {
                    const fetchedOrder = await response.json();
                    console.log("Fetched normal order status during 90s check:", fetchedOrder.status);

                    // Process normal order status
                    if (fetchedOrder.status === 'On Transit') {
                        console.log("Normal order is now on transit. Stopping checks and timer.");
                        clearInterval(intervalId); // Stop the status check
                        clearInterval(orderTimerId); // Stop the timer
                        // Call a function to update the UI to mark as delivered
                        markOrderAsDelivered(fetchedOrder);
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching order status during 90s check:', error);
            }
        }, 90 * 1000); // Check every 90 seconds
    };


    const markOrderAsDelivered = async (orderId, driverId) => {
        console.log("markOrderAsDelivered function called");

        // Check if the order is available and in transit
        if (!selectedOrder || selectedOrder?.status !== 'On Transit') {
            console.log("Order is not in transit or not selected.");
            alert('Order is not in transit, cannot mark as delivered.');
            return false; // Indicate failure
        }

        // Prepare payload for update
        const payload = {
            status: 'Delivered',
            driverId: driverId // Assuming this variable is defined
        };

        try {
            // Make the PATCH request to update the order status
            const response = await fetch(`${config.backendUrl}/api/driverUpdateOrderStatus/${orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                throw new Error('Failed to update order status');
            }

            const updatedOrder = await response.json();
            setSelectedOrder(updatedOrder); // Update the state with the new order details
            alert('Order marked as delivered successfully.');
            return true; // Indicate success
        } catch (error) {
            console.error('Error marking order as delivered:', error);
            alert('Failed to mark order as delivered.');
            return false; // Indicate failure
        }
    };

    const handleMarkAsDelivered = async () => {
        const orderId = selectedOrder?.orderId; // Use optional chaining to safely get orderId

        if (!orderId) {
            console.log("No order ID found.");
            alert('No order selected to mark as delivered.');
            return;
        }

        const success = await markOrderAsDelivered(orderId, selectedOrder.driverId); // Call the function to mark the order as delivered

        if (success) {
            console.log('Order marked as delivered successfully.');

            // Clear the UI by resetting the selected order
            setSelectedOrder(null); // Clear the currently selected order

            await fetchOrders(); // Fetch new orders from the server

            // You may want to check if orders state is updated
            console.log('Updated orders state:', orders);

            // Optionally, you can also clear any UI state related to displayed orders if applicable
            // setOrders([]); // Uncomment this if you need to clear existing displayed orders

        } else {
            console.log('Failed to mark order as delivered.');
        }
    };

    const revertOrderStatus = async (orderId, driverId) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/revertOrderStatus/${orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ driverId }) // Send driverId to ensure the correct driver
            });

            if (!response.ok) {
                throw new Error('Failed to revert order status');
            }

            console.log('Order status reverted for driver:', driverId);

            // Clear localStorage for this driver
            localStorage.removeItem(`driver_${driverId}_currentOrder`);
            localStorage.removeItem(`driver_${driverId}_timerStartTime`);
            localStorage.removeItem(`driver_${driverId}_remainingTime`);

            // **Immediately update the UI**
            await fetchOrders(); // Call fetchOrders to refresh the order list on the UI
        } catch (error) {
            console.error('Error reverting order status:', error);
        }
    };


    // Utility function to format time for the timer display
    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs < 10 ? `0${secs}` : secs}`; // Format time as MM:SS
    };


    const fetchDispatchedFoodOrders = async (driverId) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/fetchDispatchedFoodOrders/${driverId}`);

            if (!response.ok) {
                throw new Error('Failed to fetch dispatched food orders');
            }

            const dispatchedFoodOrders = await response.json();
            console.log("Dispatched food orders:", dispatchedFoodOrders);

            // Here you can set the dispatched food orders in your state or localStorage
            setSelectedOrder(dispatchedFoodOrders); // Assuming this sets the orders for display

            return dispatchedFoodOrders;
        } catch (error) {
            console.error('Error fetching dispatched food orders:', error);
            return []; // Return an empty array in case of error
        }
    };


    // Handle decline order logic
    // const handleDeclineOrder = async () => {
    //     try {
    //         const response = await fetch(`${config.backendUrl}/api/updateOrderStatus/${selectedOrder.orderId}`, {
    //             method: 'PATCH',
    //             headers: {
    //                 'Content-Type': 'application/json',
    //             },
    //             body: JSON.stringify({ status: 'Processed and packed' }), // Revert to 'Processed and packed'
    //         });

    //         if (!response.ok) {
    //             throw new Error('Failed to decline the order');
    //         }

    //         setSelectedOrder(null); // Clear selected order
    //         fetchOrders(); // Refresh the orders list
    //     } catch (error) {
    //         console.error('Error declining order:', error);
    //     }
    // };
    const handleDeclineOrder = async (order) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/updateOrderStatus/${order.orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: 'Processed and packed' }), // Modify as needed
            });
    
            if (!response.ok) {
                throw new Error('Failed to decline the order');
            }
    
            // Remove the declined order from the state
            setFoodOrders(prevOrders => prevOrders.filter(o => o.orderId !== order.orderId));
            console.log(`Order ${order.orderId} declined successfully.`);
        } catch (error) {
            console.error('Error declining order:', error);
        }
    };
    

    const handleUpdateDriver = async () => {
        const formData = new FormData();
        formData.append('location', location);
        formData.append('contactNumber', contactNumber);
        formData.append('vehicleType', vehicleType);

        if (driverImage) {
            formData.append('image', driverImage); // Include the image if available
        }

        // Check if driverDetails is set and contains the _id
        if (driverDetails && driverDetails._id) {
            formData.append('driverId', driverDetails._id); // Ensure _id exists before appending
            console.log('Driver ID:', driverDetails._id); // Log the driver ID to ensure it's set
        } else {
            console.error('Driver ID is undefined. Cannot update driver details.');
            return; // Stop execution if driverId is not available
        }

        try {
            const response = await fetch(`${config.backendUrl}/api/driverDetails`, {
                method: 'PATCH', // Use PATCH for updating
                body: formData,
            });

            if (response.ok) {
                const updatedDriver = await response.json();
                setDriverDetails(updatedDriver); // Update driver details after successful patch
                setShowProfileCard(false); // Close profile card after updating
                setEditing(false); // Reset editing mode
            } else {
                console.error('Failed to update driver details');
            }
        } catch (error) {
            console.error('Error updating driver details:', error);
        }
    };



    const handleLogout = () => {
        localStorage.removeItem('authToken');
        // localStorage.removeItem('driverId');

        navigate('/');
    };


    return (
        <div className="dial-slider_wrapper">
            <div className="dial-slider_container">
                <div className="driver_header">
                    <div className="driver_slider">
                        <label className="label_on on_off">Online</label>
                        <div className={`toggle-switch ${isOnline ? 'active' : ''}`} onClick={toggleOnlineStatus}>
                            <span className="btn_slider" style={{ left: isOnline ? 'calc(100% - 28px)' : '2px' }}></span>
                        </div>
                        <label className="label_off on_off">Offline</label>
                    </div>

                    <div className="driver_icon">
                        <i className="fas fa-user-circle driver_profile" onClick={handleProfileClick}></i>

                        {showProfileCard && (
                            <div className={`profile-card-overlay ${showProfileCard ? 'show' : ''}`}>
                                <div className="profile-cards">
                                    <div className="image">
                                        {driverImage && <img src={driverImage} alt="Driver" />}
                                        <div className="image-upload">
                                            {editing && (
                                                <>
                                                    <input
                                                        type="file"
                                                        accept="image/*"
                                                        onChange={(e) => setDriverImage(e.target.files[0])}
                                                    />
                                                    <p>{driverImage ? driverImage.name : 'No image selected'}</p>
                                                </>
                                            )}
                                        </div>
                                        <span className="name">{driverDetails.OfficialNames}</span>
                                        <span className="location">
                                            <i className="fas fa-location-dot profile_icon" aria-hidden="true"></i>
                                            {editing ? (
                                                <input
                                                    type="text"
                                                    value={location}
                                                    onChange={(e) => setLocation(e.target.value)}
                                                    placeholder="Enter your location"
                                                />
                                            ) : (
                                                <span>{driverDetails.location}</span>
                                            )}
                                        </span>
                                        <span className="contactNumber">
                                            <i className="fas fa-phone-alt profile_icon" aria-hidden="true"></i>
                                            {editing ? (
                                                <input
                                                    type="number"
                                                    value={contactNumber}
                                                    onChange={(e) => setContactNumber(e.target.value)}
                                                    placeholder="Enter your Phone Number"
                                                />
                                            ) : (
                                                <span>{driverDetails.contactNumber}</span>
                                            )}
                                        </span>
                                        <div className="Vehicle">
                                            <span className="vehicle_details">
                                                <span className="icon_label">
                                                    <i className="fas fa-user profile_icon" aria-hidden="true"></i> ID :
                                                </span>
                                                <span className="number">{driverDetails.IDNumber}</span>
                                            </span>
                                            <span className="vehicle_details">
                                                <span className="icon_label">
                                                    <i className="fas fa-drivers-license profile_icon" aria-hidden="true"></i> License :
                                                </span>
                                                <span className="number">{driverDetails.DriverLicenceNumber}</span>
                                            </span>
                                        </div>
                                        <div className="Vehicle">
                                            <span className="vehicle_details">
                                                <span className="icon_label">
                                                    <i className="fas fa-building profile_icon" aria-hidden="true"></i> Type :
                                                </span>
                                                {editing ? (
                                                    <input
                                                        type="text"
                                                        value={vehicleType}
                                                        onChange={(e) => setVehicleType(e.target.value)}
                                                        placeholder="Enter vehicle type"
                                                    />
                                                ) : (
                                                    <span>{driverDetails.vehicleType}</span>
                                                )}
                                            </span>
                                            <span className="vehicle_details">
                                                <span className="icon_label">
                                                    <i className="fas fa-car profile_icon" aria-hidden="true"></i> Plate :
                                                </span>
                                                <span className="number">{driverDetails.NumberPlate}</span>
                                            </span>
                                        </div>

                                        <div className="btn-container">
                                            <button className="edit_btn" onClick={editing ? handleUpdateDriver : () => setEditing(true)}>
                                                {editing ? 'Save Changes' : 'Edit Profile'}
                                            </button>
                                        </div>
                                        <button className="logout_btn" onClick={handleLogout}>
                                            Logout
                                        </button>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>

                <div className="driver_body">
                    {/* Check if an order is selected */}
                    {selectedOrder ? (
                        <div className="map_div">
                            <div className="order_delivery_details">
                                <p>Order ID: {selectedOrder.orderId}</p>
                                <p>Restaurant: {selectedOrder.selectedRestaurant}</p>
                                <p>Pickup Location: {selectedOrder.selectedRestaurant}</p>
                                <p>Dropoff Location: {selectedOrder.customerLocation}</p>
                                <p>Gross Delivery Charges: {selectedOrder.deliveryCharges}</p>
                                <p>Commission: {selectedOrder.commission}</p>
                                <p>Net Pay: {selectedOrder.netPay}</p>
                                <p>Expected Delivery Time: {selectedOrder.expectedDeliveryTime}</p>
                                <p>Customer Contact: {selectedOrder.phoneNumber}</p>
                                <p>Status: {selectedOrder.status}</p>
                                <p>Timer: {formatTime(timer)}</p>

                                {/* Button to mark as delivered */}
                                {selectedOrder.status === 'On Transit' ? (
                                    <button
                                        className="accept_order_btn"
                                        onClick={() => handleMarkAsDelivered(selectedOrder.orderId)}
                                    >
                                        Mark as Delivered
                                    </button>
                                ) : (
                                    <button className="decline_order_btn" onClick={handleDeclineOrder}>
                                        Decline
                                    </button>
                                )}
                            </div>
                        </div>
                    ) : (
                        // Display orders if no order is selected
                        orders.map((order) => (
                            <div className="order_container_div" key={order.id}>
                                <div className="hotel_name_div">
                                    <p className="order_p">Restaurant</p>
                                    <span className="order_detail_input">{order.name}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Pickup Location</p>
                                    <span className="order_detail_input">{order.pickup}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Order ID</p>
                                    <span className="order_detail_input">{order.orderId}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Dropoff Location</p>
                                    <span className="order_detail_input">{order.dropoff}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Delivery Charges</p>
                                    <span className="order_detail_input">{order.deliveryCharges}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Commission</p>
                                    <span className="order_detail_input">{order.commission}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Net Pay</p>
                                    <span className="order_detail_input">{order.netPay}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Expected Delivery Time</p>
                                    <span className="order_detail_input">{order.expectedDeliveryTime}</span>
                                </div>
                                <div className="hotel_name_div">
                                    <p className="order_p">Customer Contact</p>
                                    <span className="order_detail_input">{order.phoneNumber}</span>
                                </div>

                                {/* Button to accept the order */}
                                <button className="accept_order_btn" onClick={() => handleAcceptOrder(order)}>
                                    Accept Order
                                </button>
                            </div>
                        ))
                    )}
                </div>
                <div>
                    <h2>Food Orders</h2>
                    <div>
                        {foodOrders.map(order => (
                            <div key={order._id} className="order-card">
                                <h3>Order ID: {order.orderId}</h3>
                                <p>Phone Number: {order.phoneNumber}</p>
                                <p>Location: {order.customerLocation}</p>
                                <p>Expected Delivery Time: {new Date(order.expectedDeliveryTime).toLocaleString()}</p>
                                <p>Status: {order.status || order.overallStatus}</p>
                                <button onClick={() => handleDeclineOrder(order)}>Decline</button>
                            </div>
                        ))}
                    </div>
                </div>
            </div>

        </div>
    );
};

export default Dashboard;


import React, { useState, useEffect } from 'react';
import './DriverDashboard.css';
import '@fortawesome/fontawesome-free/css/all.min.css';
import config from '../../config';
import { useNavigate } from 'react-router-dom';


const Dashboard = () => {
    const [isOnline, setIsOnline] = useState(false);
    const [showProfileCard, setShowProfileCard] = useState(false);
    const [selectedOrder, setSelectedOrder] = useState(null);
    const [orders, setOrders] = useState([]);
    const [foodOrders, setFoodOrders] = useState([]); 
    const [driverDetails, setDriverDetails] = useState({});
    const [location, setLocation] = useState('');
    const [contactNumber, setContactNumber] = useState('');
    const [vehicleType, setVehicleType] = useState('');
    const [driverImage, setDriverImage] = useState(null); // New state for driver image
    const [editing, setEditing] = useState(false); // State to toggle editing mode
    const [timer, setTimer] = useState(0); // Timer state for the countdown
    const [orderTimerId, setOrderTimerId] = useState(null); // Timer ID for clearing later
    const [driverId, setDriverId] = useState(null); // Initialize state for driverId
    // const [dispatchedOrders, setDispatchedOrders] = useState([]);
    const [orderId, setOrderId] = useState(null); // State to hold orderId
    const [orderStatus, setOrderStatus] = useState('');
    const [normalOrders, setNormalOrders] = useState([]);
  



    const navigate = useNavigate();

    useEffect(() => {
        const storedDriverId = localStorage.getItem('driverId'); // Retrieve the driver ID from local storage
        if (storedDriverId) {
            console.log('Driver ID set in local storage:', storedDriverId); // Log the driverId instead
            setDriverId(storedDriverId); // Set driverId state
        } else {
            console.error('Driver ID not found in local storage');
        }
    }, []); // This runs once on mount to get the driverId

    useEffect(() => {
        if (driverId) {
            fetchDriverDetails(driverId); // Fetch driver details using the stored driver ID
            // fetchDispatchedOrders(driverId); // Fetch dispatched orders using the stored driver ID
            fetchOrders(); // Call fetchOrders if necessary
            // restoreTimerState();
            fetchOrderByStatus();
        }
    }, [driverId]); // This runs whenever driverId changes


    const fetchDriverDetails = async (driverId) => {
        console.log('Fetching details for Driver ID:', driverId); // Log the driverId
        try {
            const response = await fetch(`${config.backendUrl}/api/driverDetails/${driverId}`);
            console.log('Response status:', response.status);

            const text = await response.text();
            console.log('Response text:', text);

            if (!response.ok) {
                throw new Error('Failed to fetch driver details');
            }

            const data = JSON.parse(text);
            console.log('Fetched Driver Details:', data);

            // Check for driver ID in the response
            if (!data._id) {
                console.error('Driver ID is missing in the fetched data');
                return;
            }
            // Construct the full driver image URL
            const driverImage = `${config.backendUrl}${data.driverImage}`;

            // Update state with fetched data
            setDriverDetails(data);
            console.log('Driver Details set:', data);
            setLocation(data.location || '');
            setContactNumber(data.contactNumber || '');
            setVehicleType(data.vehicleType || '');
            setDriverImage(driverImage || null);
        } catch (error) {
            console.error('Failed to fetch driver details:', error);
        }
    };

     // Function to toggle driver's online status
     const toggleOnlineStatus = () => {
        setIsOnline((prevStatus) => !prevStatus);
    };

    const handleProfileClick = () => {
        setShowProfileCard(prev => !prev);
    };


    window.onload = () => {
        checkForOngoingOrder(); // First check if the driver has an ongoing order
        monitorOrderStatus(); // Monitor the order status to remove it upon delivery or driver decline
    };

    // Function to check for ongoing order and restore state
    // const checkForOngoingOrder = () => {
    //     const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
    //     const savedTime = localStorage.getItem(`driver_${driverId}_timerStartTime`);

    //     if (savedOrder && savedTime) {
    //         const elapsedTime = Math.floor((Date.now() - parseInt(savedTime)) / 1000);
    //         const remainingTime = 300 - elapsedTime; // 5 minutes (300 seconds) - elapsed time

    //         if (remainingTime > 0) {
    //             setSelectedOrder(JSON.parse(savedOrder)); // Restore the saved order for the specific driver
    //             startTimer(JSON.parse(savedOrder).orderId, driverId); // Resume the timer for this driver
    //             setTimer(remainingTime); // Restore the remaining time
    //         } else {
    //             // Timer has already expired, revert order status for this driver
    //             revertOrderStatus(JSON.parse(savedOrder).orderId, driverId);

    //             // Clear localStorage as the timer expired
    //             localStorage.removeItem(`driver_${driverId}_currentOrder`);
    //             localStorage.removeItem(`driver_${driverId}_timerStartTime`);
    //             localStorage.removeItem(`driver_${driverId}_remainingTime`);

    //             // No ongoing order, so fetch new orders
    //             fetchOrders();
    //         }
    //     } else {
    //         console.log("No ongoing order found for driver, fetching new orders");
    //         // No ongoing order, so fetch new orders
    //         fetchOrders();
    //     }
    // };
    const checkForOngoingOrder = async () => {
        const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
        const savedTime = localStorage.getItem(`driver_${driverId}_timerStartTime`);

        if (savedOrder && savedTime) {
            const elapsedTime = Math.floor((Date.now() - parseInt(savedTime)) / 1000);
            const remainingTime = 300 - elapsedTime; // 5 minutes (300 seconds) - elapsed time

            if (remainingTime > 0) {
                setSelectedOrder(JSON.parse(savedOrder)); // Restore the saved order for the specific driver
                startTimer(JSON.parse(savedOrder).orderId, driverId); // Resume the timer for this driver
                setTimer(remainingTime); // Restore the remaining time
            } else {
                // Timer has already expired, revert order status for this driver
                revertOrderStatus(JSON.parse(savedOrder).orderId, driverId);

                // Clear localStorage as the timer expired
                localStorage.removeItem(`driver_${driverId}_currentOrder`);
                localStorage.removeItem(`driver_${driverId}_timerStartTime`);
                localStorage.removeItem(`driver_${driverId}_remainingTime`);

                // No ongoing order, so fetch new orders
                fetchOrders();
            }
        } else {
            console.log("No ongoing order found for driver, checking for dispatched food orders");

            // Check for dispatched food orders first
            const dispatchedFoodOrders = await fetchDispatchedFoodOrders(driverId);
            if (dispatchedFoodOrders.length === 0) {
                console.log("No dispatched food orders found, fetching new orders");
                // No dispatched food orders, so fetch new orders
                fetchOrders();
            }
        }
    };



    const fetchOrders = async () => {
        try {
            // Fetch all orders
            const allOrdersResponse = await fetch(`${config.backendUrl}/api/orders`);
            const allOrdersData = await allOrdersResponse.json();
            console.log('Normal dish orders:', allOrdersData);

            // Initialize readyForPickupData
            let readyForPickupData = [];

            // Fetch orders that are ready for pickup
            try {
                const readyForPickupResponse = await fetch(`${config.backendUrl}/api/driverDashboard/orders/readyForPickup`);
                if (!readyForPickupResponse.ok) {
                    throw new Error(`HTTP error! status: ${readyForPickupResponse.status}`);
                }

                readyForPickupData = await readyForPickupResponse.json();
                console.log('Ready for pickup orders:', readyForPickupData);
            } catch (error) {
                console.warn('Could not fetch ready for pickup orders:', error);
            }

            // Check if the responses are arrays
            if (!Array.isArray(allOrdersData)) {
                console.error('Unexpected response format for all orders:', allOrdersData);
                return;
            }

            // Filter and format the processed normal dish orders
            const processedOrders = allOrdersData.filter(order => order.status === 'Processed and packed');
            const formattedProcessedOrders = processedOrders.map(order => ({
                id: order._id,
                name: order.selectedRestaurant,
                pickup: order.selectedRestaurantLocation || order.selectedRestaurant,
                order: order.orderId,
                dropoff: order.customerLocation,
                deliveryCharges: `Ksh ${order.deliveryCharges}`,
                commission: `Ksh ${order.deliveryCharges * 0.2}`,
                netPay: `Ksh ${order.deliveryCharges - (order.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(order.expectedDeliveryTime).toLocaleString(),
                phoneNumber: order.phoneNumber,
                status: order.status,
                dishes: order.dishes,
            }));
            console.log('Processed normal dish orders:', formattedProcessedOrders);

            // Fetch all food orders (new step)
            const allFoodOrdersResponse = await fetch(`${config.backendUrl}/api/foodOrders`);
            const allFoodOrdersData = await allFoodOrdersResponse.json();
            console.log('All food orders:', allFoodOrdersData);

            // Filter and format the processed food orders
            const processedFoodOrders = allFoodOrdersData.filter(foodOrder => foodOrder.status === 'Processed and packed');
            const formattedProcessedFoodOrders = processedFoodOrders.map(foodOrder => ({
                id: foodOrder._id,
                name: foodOrder.selectedRestaurant,
                pickup: foodOrder.selectedRestaurantLocation || foodOrder.selectedRestaurant,
                order: foodOrder.orderId,
                dropoff: foodOrder.customerLocation,
                deliveryCharges: `Ksh ${foodOrder.deliveryCharges}`,
                commission: `Ksh ${foodOrder.deliveryCharges * 0.2}`,
                netPay: `Ksh ${foodOrder.deliveryCharges - (foodOrder.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(foodOrder.expectedDeliveryTime).toLocaleString(),
                phoneNumber: foodOrder.phoneNumber,
                status: foodOrder.status,
                dishes: foodOrder.dishes,
            }));
            console.log('Processed food orders:', formattedProcessedFoodOrders);

            // Format the ready for pickup orders only if readyForPickupData is an array
            const formattedReadyForPickupOrders = Array.isArray(readyForPickupData) ? readyForPickupData.map(order => ({
                id: order._id,
                name: order.selectedRestaurant,
                pickup: order.selectedRestaurantLocation || order.selectedRestaurant,
                order: order.orderId,
                dropoff: order.customerLocation,
                deliveryCharges: `Ksh ${order.deliveryCharges}`,
                commission: `Ksh ${order.deliveryCharges * 0.2}`,
                netPay: `Ksh ${order.deliveryCharges - (order.deliveryCharges * 0.2)}`,
                expectedDeliveryTime: new Date(order.expectedDeliveryTime).toLocaleString(),
                phoneNumber: order.phoneNumber,
                status: order.overallStatus,
                vendorOrders: order.vendorOrders.map(vendorOrder => ({
                    vendor: vendorOrder.vendor,
                    totalPrice: vendorOrder.totalPrice,
                    foods: vendorOrder.foods.map(food => ({
                        foodName: food.foodName,
                        quantity: food.quantity,
                        price: `Ksh ${food.price}`,
                    })),
                })),
            })) : [];

            // Combine both formatted orders
            const combinedOrders = [...formattedProcessedOrders, ...formattedProcessedFoodOrders, ...formattedReadyForPickupOrders];

            // Update the state with the combined orders
            setOrders(combinedOrders);
        } catch (error) {
            console.error('Failed to fetch orders:', error);
        }
    };

    // Function to monitor order status changes (e.g., after delivery or driver decline)
    const monitorOrderStatus = async () => {
        const savedOrder = localStorage.getItem(`driver_${driverId}_currentOrder`);
        if (savedOrder) {
            const { orderId } = JSON.parse(savedOrder);

            try {
                // Fetch the current order status from the backend
                const response = await fetch(`${config.backendUrl}/api/getOrderStatus/${orderId}`);
                const orderData = await response.json();

                if (orderData.status === 'Delivered' || orderData.status === 'Declined') {
                    // Remove order from view and clear localStorage
                    setSelectedOrder(null);
                    localStorage.removeItem(`driver_${driverId}_currentOrder`);
                    localStorage.removeItem(`driver_${driverId}_timerStartTime`);
                    localStorage.removeItem(`driver_${driverId}_remainingTime`);
                }
            } catch (error) {
                console.error('Error fetching order status:', error);
            }
        }
    };

    const handleAcceptOrder = async (order) => {
        const orderId = order?.order;
        console.log("Order being accepted:", orderId);
        console.log("Driver ID:", driverId);

        if (!orderId) {
            console.error("Order ID is undefined!");
            return;
        }

        try {
            if (!driverId) {
                throw new Error('Driver ID is not set');
            }

            let response;
            let isFoodOrder = false;

            // Check if it's a food (vendor) order or a regular restaurant order
            if (order.vendorOrders && order.vendorOrders.length > 0) {
                isFoodOrder = true; // Flag for fresh food order

                // Update parent food order status to 'Dispatched'
                response = await fetch(`${config.backendUrl}/api/driverUpdateFoodOrderStatus/${orderId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        status: 'Dispatched',
                        driverId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to update parent food order status');
                }

                // Update each vendor order's status to 'Dispatched'
                for (let vendorOrder of order.vendorOrders) {
                    const vendorId = vendorOrder?._id;

                    if (!vendorId) {
                        console.warn("Vendor order without ID detected. Full details:", vendorOrder);
                        continue;
                    }

                    try {
                        const vendorResponse = await fetch(`${config.backendUrl}/api/updateVendorOrderStatus/${vendorId}`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                status: 'Dispatched'
                            })
                        });

                        if (!vendorResponse.ok) {
                            throw new Error(`Failed to update vendor order status for vendor: ${vendorOrder.vendor}`);
                        }

                        const updatedVendorOrder = await vendorResponse.json();
                        console.log(`Vendor order updated to 'Dispatched':`, updatedVendorOrder);

                    } catch (error) {
                        console.error(`Error updating vendor order with ID ${vendorId}:`, error);
                    }
                }

                // After updating all vendor orders, fetch and update the food order state
                const fetchedFoodOrder = await fetchOrderByStatus(orderId, driverId, isFoodOrder);
                setFoodOrders(prev => [...prev, fetchedFoodOrder]); // Add the fetched food order to state

            } else {
                // Update restaurant order status
                response = await fetch(`${config.backendUrl}/api/driverUpdateOrderStatus/${orderId}`, {
                    method: 'PATCH',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        status: 'Dispatched',
                        driverId
                    })
                });

                if (!response.ok) {
                    throw new Error('Failed to accept the order');
                }
            }

            const updatedOrder = await response.json();
            console.log('Order accepted and dispatched:', updatedOrder);

            // Start the timer
            setTimer(7 * 60); // 7 minutes
            startTimer(updatedOrder.orderId, driverId);

            // Clear other orders from the view
            setOrders([]);

            // Store the driver-specific order in localStorage
            localStorage.setItem(`driver_${driverId}_order`, JSON.stringify({ orderId: updatedOrder.order, driverId }));

            // Start checking the order status every 90 seconds
            await fetchOrderByStatus(updatedOrder.orderId, driverId, isFoodOrder);
            startOrderStatusCheck(updatedOrder.orderId, driverId);

        } catch (error) {
            console.error('Error accepting order:', error);
        }
    };

    // const fetchOrderByStatus = async (orderId, driverId) => {
    //     try {
    //         console.log("Fetching order by status for Order ID:", orderId, "and Driver ID:", driverId);

    //         // Attempt to fetch the normal order first
    //         const normalOrderEndpoint = `${config.backendUrl}/api/fetchOrderByStatus/${orderId}/${driverId}`;
    //         console.log("Using normal order endpoint:", normalOrderEndpoint); // Debug log for the selected endpoint

    //         let response = await fetch(normalOrderEndpoint);
    //         console.log("Normal Order Response status:", response.status); // Log the response status

    //         if (!response.ok) {
    //             console.error('Normal order fetch failed, trying food order...');
    //             // Attempt to fetch the food order if normal order fails
    //             const foodOrderEndpoint = `${config.backendUrl}/api/fetchFoodOrderByStatus/${orderId}/${driverId}`;
    //             console.log("Using food order endpoint:", foodOrderEndpoint); // Debug log for the food order endpoint

    //             response = await fetch(foodOrderEndpoint);
    //             console.log("Food Order Response status:", response.status); // Log the response status

    //             if (!response.ok) {
    //                 throw new Error(`Failed to fetch the food order by status. Status: ${response.status}`);
    //             }
    //         }

    //         // If we have a successful response, parse the order
    //         const fetchedOrder = await response.json();
    //         console.log("Fetched order:", fetchedOrder);

    //         if (!fetchedOrder) {
    //             throw new Error("No order data found");
    //         }

    //         return fetchedOrder; // Return the fetched order data
    //     } catch (error) {
    //         console.error('Error fetching order by status:', error);
    //         return null; // Return null if there's an error
    //     }
    // };

    // Fetch orders based on status and driver ID
    const fetchOrderByStatus = async (orderId, driverId, isFoodOrder = false) => {
        try {
            const endpoint = isFoodOrder
                ? `${config.backendUrl}/api/fetchFoodOrderByStatus/${orderId}/${driverId}`
                : `${config.backendUrl}/api/fetchOrderByStatus/${orderId}/${driverId}`;
            
            const response = await fetch(endpoint);
            if (!response.ok) {
                throw new Error(`Failed to fetch order by status. Status: ${response.status}`);
            }
    
            const fetchedOrder = await response.json();
            return fetchedOrder;
        } catch (error) {
            console.error('Error fetching order by status:', error);
            return null;
        }
    };

    // Fetch orders when the component mounts or driver status changes
    useEffect(() => {
        if (isOnline) {
            // Fetch orders when driver is online
            fetchOrderByStatus(null, driverId).then((fetchedOrders) => {
                setOrders(fetchedOrders || []);
            });

            // Fetch food orders
            fetchOrderByStatus(null, driverId, true).then((fetchedFoodOrders) => {
                setFoodOrders(fetchedFoodOrders || []);
            });
        } else {
            // Clear orders when offline
            setOrders([]);
            setFoodOrders([]);
        }
    }, [isOnline, driverId]);


    const startTimer = (orderId, driverId) => {
        if (orderTimerId) clearInterval(orderTimerId); // Clear previous timer if exists

        console.log(`Starting timer for Order ID: ${orderId}, Driver ID: ${driverId}`);

        const id = setInterval(async () => {
            console.log('Checking order status and updating timer...');

            // First, try to fetch the normal order status
            let fetchedOrder = await fetchOrderByStatus(orderId, driverId);

            // If the normal order is not found, attempt to fetch the food order
            if (!fetchedOrder) {
                console.log('Normal order not found, trying to fetch food order...');
                fetchedOrder = await fetchOrderByStatus(orderId, driverId, true); // Fetch food order
            }

            // Handle undefined or null fetchedOrder
            if (!fetchedOrder) {
                console.log('No order data found, stopping timer.');
                clearInterval(id);
                return;
            }

            console.log('Fetched order status:', fetchedOrder.status || fetchedOrder.overallStatus); // Log status

            // Determine which status to use
            const orderStatus = fetchedOrder.status || fetchedOrder.overallStatus;

            // Only continue counting down if the status is 'Dispatched'
            if (orderStatus === 'Dispatched') {
                setTimer(prev => {
                    console.log("Timer countdown:", prev);
                    if (prev <= 0) {
                        clearInterval(id);
                        console.log("Timer ended, calling revertOrderStatus");
                        revertOrderStatus(orderId, driverId);
                        clearDriverStorage(driverId); // Clear localStorage once timer ends
                        return 0;
                    }
                    return prev - 1; // Decrease the timer
                });
            } else {
                console.log(`Order status is ${orderStatus}, stopping timer.`);
                clearInterval(id);
            }
        }, 1000); // Check every second

        setOrderTimerId(id); // Save the timer ID
    };

    // const startTimer = (orderId, driverId) => {
    //     if (orderTimerId) clearInterval(orderTimerId); // Clear previous timer if exists

    //     console.log(`Starting timer for Order ID: ${orderId}, Driver ID: ${driverId}`);

    //     const id = setInterval(async () => {
    //         console.log('Checking order status and updating timer...');

    //         // Try to fetch the order status
    //         let fetchedOrder = await fetchOrderByStatus(orderId, driverId);

    //         // If the normal order is not found, attempt to fetch the food order
    //         if (!fetchedOrder) {
    //             console.log('Normal order not found, trying to fetch food order...');
    //             fetchedOrder = await fetchOrderByStatus(orderId, driverId, true); // Fetch food order
    //         }

    //         if (!fetchedOrder) {
    //             console.log('No order data found, stopping timer.');
    //             clearInterval(id);
    //             return;
    //         }

    //         const orderStatus = fetchedOrder.status || fetchedOrder.overallStatus;
    //         console.log('Fetched order status:', orderStatus);

    //         // Only continue counting down if the status is 'Dispatched'
    //         if (orderStatus === 'Dispatched') {
    //             setTimer(prev => {
    //                 console.log("Timer countdown:", prev);
    //                 if (prev <= 0) {
    //                     clearInterval(id);
    //                     console.log("Timer ended, calling revertOrderStatus");
    //                     revertOrderStatus(orderId, driverId);
    //                     clearDriverStorage(driverId); // Clear localStorage once timer ends
    //                     return 0;
    //                 }
    //                 return prev - 1; // Decrease the timer
    //             });
    //         } else {
    //             console.log(`Order status is ${orderStatus}, stopping timer.`);
    //             clearInterval(id);
    //         }
    //     }, 1000); // Check every second

    //     setOrderTimerId(id); // Save the timer ID
    // };


    const clearDriverStorage = (driverId) => {
        localStorage.removeItem(`driver_${driverId}_currentOrder`);
        localStorage.removeItem(`driver_${driverId}_timerStartTime`);
        localStorage.removeItem(`driver_${driverId}_remainingTime`);
    };

    const startOrderStatusCheck = (orderId, driverId) => {
        console.log(`Starting status check for Order ID: ${orderId}, Driver ID: ${driverId}`);
        const intervalId = setInterval(async () => {
            try {
                const response = await fetch(`${config.backendUrl}/api/fetchOrderByStatus/${orderId}/${driverId}`);
                if (!response.ok) {
                    console.error('Failed to fetch the order status, trying food orders...');
                    // If the normal order fetch fails, try fetching the food order
                    const foodResponse = await fetch(`${config.backendUrl}/api/fetchFoodOrderByStatus/${orderId}/${driverId}`);
                    if (!foodResponse.ok) {
                        throw new Error('Failed to fetch the food order status');
                    }

                    const fetchedFoodOrder = await foodResponse.json();
                    console.log("Fetched food order status during 90s check:", fetchedFoodOrder.overallStatus);

                    // Process food order status
                    if (fetchedFoodOrder.overallStatus === 'On Transit') {
                        console.log("Food order is now on transit. Stopping checks and timer.");
                        clearInterval(intervalId); // Stop the status check
                        clearInterval(orderTimerId); // Stop the timer
                        // Call a function to update the UI to mark as delivered
                        markOrderAsDelivered(fetchedFoodOrder);
                        return;
                    }
                } else {
                    const fetchedOrder = await response.json();
                    console.log("Fetched normal order status during 90s check:", fetchedOrder.status);

                    // Process normal order status
                    if (fetchedOrder.status === 'On Transit') {
                        console.log("Normal order is now on transit. Stopping checks and timer.");
                        clearInterval(intervalId); // Stop the status check
                        clearInterval(orderTimerId); // Stop the timer
                        // Call a function to update the UI to mark as delivered
                        markOrderAsDelivered(fetchedOrder);
                        return;
                    }
                }
            } catch (error) {
                console.error('Error fetching order status during 90s check:', error);
            }
        }, 90 * 1000); // Check every 90 seconds
    };


    const markOrderAsDelivered = async (orderId, driverId) => {
        console.log("markOrderAsDelivered function called");

        // Check if the order is available and in transit
        if (!selectedOrder || selectedOrder?.status !== 'On Transit') {
            console.log("Order is not in transit or not selected.");
            alert('Order is not in transit, cannot mark as delivered.');
            return false; // Indicate failure
        }

        // Prepare payload for update
        const payload = {
            status: 'Delivered',
            driverId: driverId // Assuming this variable is defined
        };

        try {
            // Make the PATCH request to update the order status
            const response = await fetch(`${config.backendUrl}/api/driverUpdateOrderStatus/${orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                throw new Error('Failed to update order status');
            }

            const updatedOrder = await response.json();
            setSelectedOrder(updatedOrder); // Update the state with the new order details
            alert('Order marked as delivered successfully.');
            return true; // Indicate success
        } catch (error) {
            console.error('Error marking order as delivered:', error);
            alert('Failed to mark order as delivered.');
            return false; // Indicate failure
        }
    };

    const handleMarkAsDelivered = async () => {
        const orderId = selectedOrder?.orderId; // Use optional chaining to safely get orderId

        if (!orderId) {
            console.log("No order ID found.");
            alert('No order selected to mark as delivered.');
            return;
        }

        const success = await markOrderAsDelivered(orderId, selectedOrder.driverId); // Call the function to mark the order as delivered

        if (success) {
            console.log('Order marked as delivered successfully.');

            // Clear the UI by resetting the selected order
            setSelectedOrder(null); // Clear the currently selected order

            await fetchOrders(); // Fetch new orders from the server

            // You may want to check if orders state is updated
            console.log('Updated orders state:', orders);

            // Optionally, you can also clear any UI state related to displayed orders if applicable
            // setOrders([]); // Uncomment this if you need to clear existing displayed orders

        } else {
            console.log('Failed to mark order as delivered.');
        }
    };

    const revertOrderStatus = async (orderId, driverId) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/revertOrderStatus/${orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ driverId }) // Send driverId to ensure the correct driver
            });

            if (!response.ok) {
                throw new Error('Failed to revert order status');
            }

            console.log('Order status reverted for driver:', driverId);

            // Clear localStorage for this driver
            localStorage.removeItem(`driver_${driverId}_currentOrder`);
            localStorage.removeItem(`driver_${driverId}_timerStartTime`);
            localStorage.removeItem(`driver_${driverId}_remainingTime`);

            // **Immediately update the UI**
            await fetchOrders(); // Call fetchOrders to refresh the order list on the UI
        } catch (error) {
            console.error('Error reverting order status:', error);
        }
    };


    // Utility function to format time for the timer display
    const formatTime = (seconds) => {
        const minutes = Math.floor(seconds / 60);
        const secs = seconds % 60;
        return `${minutes}:${secs < 10 ? `0${secs}` : secs}`; // Format time as MM:SS
    };


    const fetchDispatchedFoodOrders = async (driverId) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/fetchDispatchedFoodOrders/${driverId}`);

            if (!response.ok) {
                throw new Error('Failed to fetch dispatched food orders');
            }

            const dispatchedFoodOrders = await response.json();
            console.log("Dispatched food orders:", dispatchedFoodOrders);

            // Here you can set the dispatched food orders in your state or localStorage
            setSelectedOrder(dispatchedFoodOrders); // Assuming this sets the orders for display

            return dispatchedFoodOrders;
        } catch (error) {
            console.error('Error fetching dispatched food orders:', error);
            return []; // Return an empty array in case of error
        }
    };


    // Handle decline order logic
    // const handleDeclineOrder = async () => {
    //     try {
    //         const response = await fetch(`${config.backendUrl}/api/updateOrderStatus/${selectedOrder.orderId}`, {
    //             method: 'PATCH',
    //             headers: {
    //                 'Content-Type': 'application/json',
    //             },
    //             body: JSON.stringify({ status: 'Processed and packed' }), // Revert to 'Processed and packed'
    //         });

    //         if (!response.ok) {
    //             throw new Error('Failed to decline the order');
    //         }

    //         setSelectedOrder(null); // Clear selected order
    //         fetchOrders(); // Refresh the orders list
    //     } catch (error) {
    //         console.error('Error declining order:', error);
    //     }
    // };
    const handleDeclineOrder = async (order) => {
        try {
            const response = await fetch(`${config.backendUrl}/api/updateOrderStatus/${order.orderId}`, {
                method: 'PATCH',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ status: 'Processed and packed' }), // Modify as needed
            });
    
            if (!response.ok) {
                throw new Error('Failed to decline the order');
            }
    
            // Remove the declined order from the state
            setFoodOrders(prevOrders => prevOrders.filter(o => o.orderId !== order.orderId));
            console.log(`Order ${order.orderId} declined successfully.`);
        } catch (error) {
            console.error('Error declining order:', error);
        }
    };
    

    const handleUpdateDriver = async () => {
        const formData = new FormData();
        formData.append('location', location);
        formData.append('contactNumber', contactNumber);
        formData.append('vehicleType', vehicleType);

        if (driverImage) {
            formData.append('image', driverImage); // Include the image if available
        }

        // Check if driverDetails is set and contains the _id
        if (driverDetails && driverDetails._id) {
            formData.append('driverId', driverDetails._id); // Ensure _id exists before appending
            console.log('Driver ID:', driverDetails._id); // Log the driver ID to ensure it's set
        } else {
            console.error('Driver ID is undefined. Cannot update driver details.');
            return; // Stop execution if driverId is not available
        }

        try {
            const response = await fetch(`${config.backendUrl}/api/driverDetails`, {
                method: 'PATCH', // Use PATCH for updating
                body: formData,
            });

            if (response.ok) {
                const updatedDriver = await response.json();
                setDriverDetails(updatedDriver); // Update driver details after successful patch
                setShowProfileCard(false); // Close profile card after updating
                setEditing(false); // Reset editing mode
            } else {
                console.error('Failed to update driver details');
            }
        } catch (error) {
            console.error('Error updating driver details:', error);
        }
    };



    const handleLogout = () => {
        localStorage.removeItem('authToken');
        // localStorage.removeItem('driverId');

        navigate('/');
    };


    return (
        <div className="dial-slider_wrapper">
        <div className="dial-slider_container">
            <div className="driver_header">
                <div className="driver_slider">
                    <label className="label_on on_off">Online</label>
                    <div className={`toggle-switch ${isOnline ? 'active' : ''}`} onClick={toggleOnlineStatus}>
                        <span className="btn_slider" style={{ left: isOnline ? 'calc(100% - 28px)' : '2px' }}></span>
                    </div>
                    <label className="label_off on_off">Offline</label>
                </div>
            </div>

            <div className="driver_body">
                {/* Check if an order is selected */}
                {selectedOrder ? (
                    <div className="map_div">
                        <div className="order_delivery_details">
                            <p>Order ID: {selectedOrder.orderId}</p>
                            <p>Restaurant: {selectedOrder.selectedRestaurant}</p>
                            <p>Pickup Location: {selectedOrder.pickup}</p>
                            <p>Dropoff Location: {selectedOrder.customerLocation}</p>
                            <p>Delivery Charges: {selectedOrder.deliveryCharges}</p>
                            <p>Commission: {selectedOrder.commission}</p>
                            <p>Net Pay: {selectedOrder.netPay}</p>
                            <p>Expected Delivery Time: {selectedOrder.expectedDeliveryTime}</p>
                            <p>Status: {selectedOrder.status}</p>
                            {/* Button to mark as delivered */}
                            {selectedOrder.status === 'On Transit' && (
                                <button className="accept_order_btn" onClick={() => handleMarkAsDelivered(selectedOrder.orderId)}>
                                    Mark as Delivered
                                </button>
                            )}
                        </div>
                    </div>
                ) : (
                    <div>
                        <h2>Available Orders</h2>
                        {orders.map((order) => (
                            <div className="order_container_div" key={order.orderId}>
                                <p>Order ID: {order.orderId}</p>
                                <p>Pickup Location: {order.pickup}</p>
                                <p>Dropoff Location: {order.dropoff}</p>
                                <p>Delivery Charges: {order.deliveryCharges}</p>
                                <button className="accept_order_btn" onClick={() => handleAcceptOrder(order)}>
                                    Accept Order
                                </button>
                            </div>
                        ))}
                    </div>
                )}

                {/* Display food orders */}
                <div>
                    <h2>Food Orders</h2>
                    {foodOrders.map((order) => (
                        <div key={order.orderId} className="order-card">
                            <h3>Order ID: {order.orderId}</h3>
                            <p>Location: {order.customerLocation}</p>
                            <p>Expected Delivery Time: {new Date(order.expectedDeliveryTime).toLocaleString()}</p>
                            <p>Status: {order.status}</p>
                            <button onClick={() => handleAcceptOrder(order)}>Accept Order</button>
                        </div>
                    ))}
                </div>
            </div>
        </div>
    </div>
);
};

export default Dashboard;
